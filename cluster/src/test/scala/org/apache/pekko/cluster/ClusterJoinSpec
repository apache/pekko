/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.pekko.cluster

import com.typesafe.config.{ Config, ConfigFactory }

import org.apache.pekko
import pekko.testkit.{ LongRunningTest, PekkoSpec }

object ClusterJoinSpec {

  import PekkoSpec._

  val baseConfig: Config =
    ConfigFactory.parseString("""
      pekko.actor.provider = "cluster"
      pekko.coordinated-shutdown.terminate-actor-system = on

      pekko.remote.artery.canonical.port = 0
      pekko.remote.classic.netty.tcp.port = 0
      pekko.remote.artery.advanced.aeron.idle-cpu-level = 3

      pekko.cluster.jmx.multi-mbeans-in-same-jvm = on""")


  val configWithNetty: Config =
    ConfigFactory.parseString("""
      pekko.remote.artery.enabled = false
      pekko.remote.classic {
        enabled-transports = ["pekko.remote.classic.netty.tcp"]
      }
    """).withFallback(baseConfig)

  val configWithNettySsl: Config =
    ConfigFactory.parseString(s"""
      pekko.remote.classic {
        enabled-transports = ["pekko.remote.classic.netty.ssl"]
        netty.ssl.hostname = "localhost"
        netty.ssl.port = 0
        netty.ssl.security = {
          key-store = "${resourcePath("keystore")}"
          trust-store = "${resourcePath("truststore")}"
          key-store-password = "changeme"
          key-password = "changeme"
          trust-store-password = "changeme"
          protocol = "TLSv1.2"
          enabled-algorithms = [TLS_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_256_GCM_SHA384]
        }
      }
    """).withFallback(configWithNetty)
}

class ClusterJoinSpec extends PekkoSpec with ClusterTestKit {

  import ClusterJoinSpec._

  "Cluster Forming" must {

    "allow a cluster with just pekko nodes (netty ssl)" taggedAs LongRunningTest in {
      val clusterTestUtil = new ClusterTestUtil(system.name)
      try {
        // create the first node with the "pekko" protocol
        clusterTestUtil.newActorSystem(configWithPekkoNettySsl)

        // have a node using the "pekko" protocol join
        val joiningNode = clusterTestUtil.newActorSystem(configWithPekkoNettySsl)
        clusterTestUtil.formCluster()

        awaitCond(clusterTestUtil.isMemberUp(joiningNode), message = "awaiting joining node to be 'Up'")
      } finally {
        clusterTestUtil.shutdownAll()
      }
    }

  }
}
